#!/usr/bin/env python3
"""
Vulnerability Chaining Engine for Argus Security
Discovers and analyzes multi-step attack scenarios by chaining vulnerabilities

Author: Argus Security Team
License: MIT
"""

import hashlib
import json
import logging
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Optional

try:
    import networkx as nx
    NETWORKX_AVAILABLE = True
except ImportError:
    NETWORKX_AVAILABLE = False
    logging.warning("networkx not available - using fallback graph implementation")

logger = logging.getLogger(__name__)


class AttackComplexity(Enum):
    """Attack complexity levels"""
    TRIVIAL = "trivial"      # 1 step, no authentication
    LOW = "low"              # 2-3 steps, basic authentication
    MEDIUM = "medium"        # 3-4 steps, multiple hurdles
    HIGH = "high"            # 4+ steps, complex prerequisites


class ChainExploitability(Enum):
    """Overall chain exploitability"""
    CRITICAL = "critical"    # Trivial to exploit, immediate threat
    HIGH = "high"            # Easy to exploit, realistic threat
    MODERATE = "moderate"    # Requires skills, possible threat
    LOW = "low"              # Difficult to exploit, theoretical
    UNLIKELY = "unlikely"    # Very difficult, highly theoretical


@dataclass
class VulnerabilityNode:
    """A vulnerability node in the attack graph"""
    
    id: str
    category: str
    severity: str  # critical, high, medium, low
    title: str
    description: str
    file_path: str
    line_number: Optional[int] = None
    cwe: Optional[str] = None
    cvss_score: float = 0.0
    exploitability: str = "unknown"  # trivial, moderate, difficult
    reachability: str = "unknown"    # yes, no, partial
    remediation: str = ""
    references: list[str] = field(default_factory=list)
    metadata: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        """Convert to dictionary"""
        return {
            'id': self.id,
            'category': self.category,
            'severity': self.severity,
            'title': self.title,
            'description': self.description,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'cwe': self.cwe,
            'cvss_score': self.cvss_score,
            'exploitability': self.exploitability,
            'reachability': self.reachability,
            'remediation': self.remediation,
            'references': self.references,
            'metadata': self.metadata,
        }
    
    def severity_to_score(self) -> float:
        """Convert severity to numeric score"""
        severity_scores = {
            'critical': 10.0,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'info': 1.0,
        }
        return severity_scores.get(self.severity.lower(), 5.0)


@dataclass
class AttackChain:
    """A sequence of vulnerabilities that can be chained together"""
    
    vulnerabilities: list[VulnerabilityNode]
    chain_id: str = ""
    risk_score: float = 0.0
    base_risk: float = 0.0
    amplification_factor: float = 1.0
    complexity: AttackComplexity = AttackComplexity.MEDIUM
    exploitability: ChainExploitability = ChainExploitability.MODERATE
    attack_scenario: str = ""
    final_impact: str = ""
    prerequisites: list[str] = field(default_factory=list)
    mitigation_priority: int = 5  # 1-10, 10 = highest
    estimated_exploit_time: str = ""  # "< 1 hour", "1-4 hours", etc.
    
    def __post_init__(self):
        """Calculate derived attributes"""
        if not self.chain_id:
            self.chain_id = self._generate_chain_id()
        if self.risk_score == 0.0:
            self.risk_score = self._calculate_risk()
        if not self.complexity or self.complexity == AttackComplexity.MEDIUM:
            self.complexity = self._determine_complexity()
        if not self.exploitability or self.exploitability == ChainExploitability.MODERATE:
            self.exploitability = self._determine_exploitability()
    
    def _generate_chain_id(self) -> str:
        """Generate unique chain ID"""
        vuln_ids = "|".join([v.id for v in self.vulnerabilities])
        return hashlib.sha256(vuln_ids.encode()).hexdigest()[:16]
    
    def _calculate_risk(self) -> float:
        """Calculate amplified risk score"""
        # Base risk (sum of individual severities)
        self.base_risk = sum(v.severity_to_score() for v in self.vulnerabilities)
        
        # Amplification factor (exponential based on chain length)
        # 2 vulns: 1.5x, 3 vulns: 2.25x, 4 vulns: 3.375x
        self.amplification_factor = 1.5 ** (len(self.vulnerabilities) - 1)
        
        # Amplified risk (capped at 10.0)
        amplified_risk = self.base_risk * self.amplification_factor
        
        return min(amplified_risk, 10.0)
    
    def _determine_complexity(self) -> AttackComplexity:
        """Determine attack complexity"""
        chain_length = len(self.vulnerabilities)
        
        # Check if all vulns are easy to exploit
        all_trivial = all(v.exploitability == "trivial" for v in self.vulnerabilities)
        any_difficult = any(v.exploitability == "difficult" for v in self.vulnerabilities)
        
        if chain_length == 1 and all_trivial:
            return AttackComplexity.TRIVIAL
        elif chain_length <= 2 and not any_difficult:
            return AttackComplexity.LOW
        elif chain_length <= 3:
            return AttackComplexity.MEDIUM
        else:
            return AttackComplexity.HIGH
    
    def _determine_exploitability(self) -> ChainExploitability:
        """Determine overall exploitability"""
        # Based on risk score and complexity
        if self.risk_score >= 9.0 and self.complexity in [AttackComplexity.TRIVIAL, AttackComplexity.LOW]:
            return ChainExploitability.CRITICAL
        elif self.risk_score >= 7.5 and self.complexity != AttackComplexity.HIGH:
            return ChainExploitability.HIGH
        elif self.risk_score >= 5.0:
            return ChainExploitability.MODERATE
        elif self.risk_score >= 2.5:
            return ChainExploitability.LOW
        else:
            return ChainExploitability.UNLIKELY
    
    def to_dict(self) -> dict:
        """Convert to dictionary"""
        return {
            'chain_id': self.chain_id,
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'risk_score': round(self.risk_score, 2),
            'base_risk': round(self.base_risk, 2),
            'amplification_factor': round(self.amplification_factor, 2),
            'complexity': self.complexity.value,
            'exploitability': self.exploitability.value,
            'attack_scenario': self.attack_scenario,
            'final_impact': self.final_impact,
            'prerequisites': self.prerequisites,
            'mitigation_priority': self.mitigation_priority,
            'estimated_exploit_time': self.estimated_exploit_time,
            'chain_length': len(self.vulnerabilities),
        }


class AttackGraph:
    """Directed graph of vulnerabilities and their exploitable relationships"""
    
    def __init__(self):
        """Initialize attack graph"""
        if NETWORKX_AVAILABLE:
            self.graph = nx.DiGraph()
        else:
            self.graph = self._create_fallback_graph()
        
        self.vulnerabilities: dict[str, VulnerabilityNode] = {}
        self.chain_rules = self._load_chain_rules()
    
    def _create_fallback_graph(self) -> dict:
        """Create simple fallback graph implementation"""
        return {
            'nodes': {},
            'edges': [],
        }
    
    def _load_chain_rules(self) -> list[dict]:
        """Load vulnerability chaining rules"""
        return [
            # IDOR â†’ Privilege Escalation â†’ Data Breach
            {
                'source': 'IDOR',
                'target': 'PRIVILEGE_ESCALATION',
                'probability': 0.8,
                'description': 'IDOR allows accessing other user resources, enabling privilege escalation'
            },
            {
                'source': 'PRIVILEGE_ESCALATION',
                'target': 'DATA_BREACH',
                'probability': 0.9,
                'description': 'Elevated privileges allow accessing sensitive data'
            },
            
            # XSS â†’ Session Hijacking â†’ Account Takeover
            {
                'source': 'XSS',
                'target': 'SESSION_HIJACKING',
                'probability': 0.85,
                'description': 'XSS can steal session tokens via JavaScript'
            },
            {
                'source': 'SESSION_HIJACKING',
                'target': 'ACCOUNT_TAKEOVER',
                'probability': 0.95,
                'description': 'Stolen session allows complete account access'
            },
            
            # SSRF â†’ Internal Network Access â†’ RCE
            {
                'source': 'SSRF',
                'target': 'INTERNAL_NETWORK_ACCESS',
                'probability': 0.75,
                'description': 'SSRF enables access to internal services'
            },
            {
                'source': 'INTERNAL_NETWORK_ACCESS',
                'target': 'RCE',
                'probability': 0.6,
                'description': 'Internal services may have additional vulnerabilities'
            },
            
            # Path Traversal â†’ File Read â†’ Credential Exposure
            {
                'source': 'PATH_TRAVERSAL',
                'target': 'ARBITRARY_FILE_READ',
                'probability': 0.9,
                'description': 'Path traversal allows reading arbitrary files'
            },
            {
                'source': 'ARBITRARY_FILE_READ',
                'target': 'CREDENTIAL_EXPOSURE',
                'probability': 0.7,
                'description': 'File read can expose configuration files with credentials'
            },
            
            # SQL Injection â†’ Database Access â†’ Data Exfiltration
            {
                'source': 'SQL_INJECTION',
                'target': 'DATABASE_ACCESS',
                'probability': 0.95,
                'description': 'SQLi provides direct database access'
            },
            {
                'source': 'DATABASE_ACCESS',
                'target': 'DATA_EXFILTRATION',
                'probability': 0.9,
                'description': 'Database access enables bulk data extraction'
            },
            
            # CSRF â†’ Unauthorized Action â†’ Data Modification
            {
                'source': 'CSRF',
                'target': 'UNAUTHORIZED_ACTION',
                'probability': 0.8,
                'description': 'CSRF forces victim to perform unwanted actions'
            },
            {
                'source': 'UNAUTHORIZED_ACTION',
                'target': 'DATA_MODIFICATION',
                'probability': 0.85,
                'description': 'Unauthorized actions can modify critical data'
            },
            
            # Broken Authentication â†’ Account Access â†’ Data Breach
            {
                'source': 'BROKEN_AUTH',
                'target': 'ACCOUNT_ACCESS',
                'probability': 0.9,
                'description': 'Authentication bypass allows account access'
            },
            {
                'source': 'ACCOUNT_ACCESS',
                'target': 'DATA_BREACH',
                'probability': 0.85,
                'description': 'Account access leads to data exposure'
            },
            
            # Command Injection â†’ System Access â†’ Backdoor Installation
            {
                'source': 'COMMAND_INJECTION',
                'target': 'SYSTEM_ACCESS',
                'probability': 0.9,
                'description': 'Command injection provides system-level access'
            },
            {
                'source': 'SYSTEM_ACCESS',
                'target': 'BACKDOOR_INSTALLATION',
                'probability': 0.8,
                'description': 'System access enables persistent backdoors'
            },
        ]
    
    def add_vulnerability(self, vuln: VulnerabilityNode):
        """Add vulnerability node to graph"""
        self.vulnerabilities[vuln.id] = vuln
        
        if NETWORKX_AVAILABLE:
            self.graph.add_node(vuln.id, data=vuln)
        else:
            self.graph['nodes'][vuln.id] = vuln
    
    def can_chain(self, source: VulnerabilityNode, target: VulnerabilityNode) -> tuple[bool, float]:
        """Check if two vulnerabilities can be chained"""
        
        # Normalize categories for matching
        source_cat = self._normalize_category(source.category)
        target_cat = self._normalize_category(target.category)
        
        # Check chaining rules
        for rule in self.chain_rules:
            if rule['source'] == source_cat and rule['target'] == target_cat:
                return True, rule['probability']
        
        # Check if same file (higher likelihood of chaining)
        if source.file_path == target.file_path:
            return True, 0.6
        
        # Check for related categories
        related_pairs = self._get_related_categories()
        if (source_cat, target_cat) in related_pairs:
            return True, 0.5
        
        return False, 0.0
    
    def _normalize_category(self, category: str) -> str:
        """Normalize vulnerability category to standard format"""
        category_map = {
            'idor': 'IDOR',
            'insecure-direct-object-reference': 'IDOR',
            'xss': 'XSS',
            'cross-site-scripting': 'XSS',
            'sqli': 'SQL_INJECTION',
            'sql-injection': 'SQL_INJECTION',
            'ssrf': 'SSRF',
            'server-side-request-forgery': 'SSRF',
            'path-traversal': 'PATH_TRAVERSAL',
            'directory-traversal': 'PATH_TRAVERSAL',
            'csrf': 'CSRF',
            'cross-site-request-forgery': 'CSRF',
            'auth': 'BROKEN_AUTH',
            'authentication': 'BROKEN_AUTH',
            'broken-auth': 'BROKEN_AUTH',
            'command-injection': 'COMMAND_INJECTION',
            'rce': 'RCE',
            'remote-code-execution': 'RCE',
        }
        
        normalized = category.lower().replace('_', '-')
        return category_map.get(normalized, category.upper())
    
    def _get_related_categories(self) -> set[tuple[str, str]]:
        """Get related vulnerability category pairs"""
        return {
            ('XSS', 'CSRF'),
            ('IDOR', 'BROKEN_AUTH'),
            ('PATH_TRAVERSAL', 'ARBITRARY_FILE_READ'),
            ('SSRF', 'INTERNAL_NETWORK_ACCESS'),
        }
    
    def build_graph(self):
        """Build complete attack graph with edges"""
        logger.info(f"Building attack graph with {len(self.vulnerabilities)} vulnerabilities")
        
        # Add edges between chainable vulnerabilities
        edge_count = 0
        for source_id, source_vuln in self.vulnerabilities.items():
            for target_id, target_vuln in self.vulnerabilities.items():
                if source_id == target_id:
                    continue
                
                can_chain, probability = self.can_chain(source_vuln, target_vuln)
                
                if can_chain:
                    if NETWORKX_AVAILABLE:
                        self.graph.add_edge(
                            source_id,
                            target_id,
                            weight=probability,
                            probability=probability
                        )
                    else:
                        self.graph['edges'].append({
                            'source': source_id,
                            'target': target_id,
                            'probability': probability
                        })
                    edge_count += 1
        
        logger.info(f"Attack graph built: {len(self.vulnerabilities)} nodes, {edge_count} edges")
    
    def find_entry_points(self) -> list[VulnerabilityNode]:
        """Find vulnerabilities that are entry points (externally accessible)"""
        entry_points = []
        
        for vuln in self.vulnerabilities.values():
            # Entry points are:
            # 1. Trivially exploitable
            # 2. Externally reachable
            # 3. Don't require prior exploitation
            if (vuln.exploitability == "trivial" and 
                vuln.reachability == "yes"):
                entry_points.append(vuln)
        
        # If no trivial entry points, include moderate ones
        if not entry_points:
            for vuln in self.vulnerabilities.values():
                if vuln.reachability == "yes":
                    entry_points.append(vuln)
        
        return entry_points
    
    def find_high_value_targets(self) -> list[VulnerabilityNode]:
        """Find high-value target vulnerabilities"""
        high_value_categories = {
            'DATA_BREACH', 'RCE', 'ACCOUNT_TAKEOVER', 'PRIVILEGE_ESCALATION',
            'BACKDOOR_INSTALLATION', 'DATA_EXFILTRATION', 'CREDENTIAL_EXPOSURE',
            'SYSTEM_ACCESS'
        }
        
        targets = []
        for vuln in self.vulnerabilities.values():
            normalized_cat = self._normalize_category(vuln.category)
            
            if (normalized_cat in high_value_categories or 
                vuln.severity in ['critical', 'high']):
                targets.append(vuln)
        
        return targets


class VulnerabilityChainer:
    """Main engine for detecting and analyzing vulnerability chains"""
    
    def __init__(self, max_chain_length: int = 4, min_risk_threshold: float = 5.0):
        """
        Initialize vulnerability chainer
        
        Args:
            max_chain_length: Maximum vulnerabilities in a chain
            min_risk_threshold: Minimum risk score to report
        """
        self.max_chain_length = max_chain_length
        self.min_risk_threshold = min_risk_threshold
        self.graph = AttackGraph()
    
    def analyze(self, findings: list[dict]) -> dict:
        """
        Analyze findings for vulnerability chains
        
        Args:
            findings: List of vulnerability findings
            
        Returns:
            Dictionary with chains and statistics
        """
        logger.info(f"ðŸ”— Starting vulnerability chaining analysis on {len(findings)} findings")
        start_time = datetime.now()
        
        # Convert findings to vulnerability nodes
        for finding in findings:
            vuln = self._finding_to_node(finding)
            self.graph.add_vulnerability(vuln)
        
        # Build attack graph
        self.graph.build_graph()
        
        # Find attack chains
        chains = self._find_chains()
        
        # Generate attack scenarios
        for chain in chains:
            chain.attack_scenario = self._generate_attack_scenario(chain)
            chain.final_impact = self._determine_final_impact(chain)
            chain.estimated_exploit_time = self._estimate_exploit_time(chain)
        
        # Calculate statistics
        duration = (datetime.now() - start_time).total_seconds()
        
        result = {
            'timestamp': datetime.now().isoformat(),
            'total_vulnerabilities': len(findings),
            'total_chains': len(chains),
            'chains': [chain.to_dict() for chain in chains],
            'statistics': self._calculate_statistics(chains),
            'duration_seconds': duration,
        }
        
        logger.info(f"âœ… Chaining analysis complete: {len(chains)} chains found in {duration:.1f}s")
        
        return result
    
    def _finding_to_node(self, finding: dict) -> VulnerabilityNode:
        """Convert a finding dict to VulnerabilityNode"""
        return VulnerabilityNode(
            id=finding.get('id', finding.get('rule_id', 'unknown')),
            category=finding.get('category', finding.get('check_id', 'unknown')),
            severity=finding.get('severity', 'medium'),
            title=finding.get('title', finding.get('message', 'Unknown')),
            description=finding.get('description', finding.get('message', '')),
            file_path=finding.get('path', finding.get('file', 'unknown')),
            line_number=finding.get('line', finding.get('start_line')),
            cwe=finding.get('cwe'),
            cvss_score=finding.get('cvss_score', 0.0),
            exploitability=finding.get('exploitability', 'unknown'),
            reachability=finding.get('reachability', 'unknown'),
            remediation=finding.get('remediation', ''),
            references=finding.get('references', []),
            metadata=finding.get('metadata', {}),
        )
    
    def _find_chains(self) -> list[AttackChain]:
        """Find all vulnerability chains in the graph"""
        chains = []
        
        # Get entry points and targets
        entry_points = self.graph.find_entry_points()
        high_value_targets = self.graph.find_high_value_targets()
        
        logger.info(f"   Found {len(entry_points)} entry points, {len(high_value_targets)} high-value targets")
        
        if not entry_points:
            logger.warning("   No entry points found, using all vulnerabilities")
            entry_points = list(self.graph.vulnerabilities.values())[:5]  # Limit to 5
        
        if not high_value_targets:
            logger.warning("   No high-value targets found, using critical/high severity vulns")
            high_value_targets = [
                v for v in self.graph.vulnerabilities.values()
                if v.severity in ['critical', 'high']
            ][:5]
        
        # Find paths from entry points to high-value targets
        for entry in entry_points:
            for target in high_value_targets:
                if entry.id == target.id:
                    continue
                
                paths = self._find_paths(entry.id, target.id)
                
                for path in paths:
                    chain = AttackChain(
                        vulnerabilities=[self.graph.vulnerabilities[vid] for vid in path]
                    )
                    
                    # Only include chains above risk threshold
                    if chain.risk_score >= self.min_risk_threshold:
                        chains.append(chain)
        
        # Sort by risk score (descending)
        chains.sort(key=lambda c: c.risk_score, reverse=True)
        
        # Remove duplicate chains (same vulnerabilities, different order)
        chains = self._deduplicate_chains(chains)
        
        return chains
    
    def _find_paths(self, source_id: str, target_id: str) -> list[list[str]]:
        """Find all paths from source to target"""
        if NETWORKX_AVAILABLE:
            try:
                paths = list(nx.all_simple_paths(
                    self.graph.graph,
                    source_id,
                    target_id,
                    cutoff=self.max_chain_length
                ))
                return paths
            except (nx.NetworkXNoPath, nx.NodeNotFound):
                return []
        else:
            # Fallback: simple DFS
            return self._find_paths_dfs(source_id, target_id, [], set())
    
    def _find_paths_dfs(self, current: str, target: str, 
                        path: list[str], visited: set) -> list[list[str]]:
        """DFS to find paths (fallback when networkx not available)"""
        if len(path) >= self.max_chain_length:
            return []
        
        path = path + [current]
        visited = visited | {current}
        
        if current == target:
            return [path]
        
        paths = []
        for edge in self.graph.graph['edges']:
            if edge['source'] == current and edge['target'] not in visited:
                new_paths = self._find_paths_dfs(edge['target'], target, path, visited)
                paths.extend(new_paths)
        
        return paths
    
    def _deduplicate_chains(self, chains: list[AttackChain]) -> list[AttackChain]:
        """Remove duplicate chains"""
        seen = set()
        unique_chains = []
        
        for chain in chains:
            # Create signature from sorted vulnerability IDs
            vuln_ids = tuple(sorted([v.id for v in chain.vulnerabilities]))
            
            if vuln_ids not in seen:
                seen.add(vuln_ids)
                unique_chains.append(chain)
        
        return unique_chains
    
    def _generate_attack_scenario(self, chain: AttackChain) -> str:
        """Generate human-readable attack scenario"""
        steps = []
        
        for i, vuln in enumerate(chain.vulnerabilities, 1):
            step = f"Step {i}: Exploit {vuln.category} in {vuln.file_path}"
            if vuln.description:
                step += f" - {vuln.description[:100]}"
            steps.append(step)
        
        return "\n".join(steps)
    
    def _determine_final_impact(self, chain: AttackChain) -> str:
        """Determine the final impact of the chain"""
        final_vuln = chain.vulnerabilities[-1]
        category = self.graph._normalize_category(final_vuln.category)
        
        impact_descriptions = {
            'DATA_BREACH': 'Complete data breach - sensitive information exposed',
            'RCE': 'Remote code execution - full system compromise',
            'ACCOUNT_TAKEOVER': 'Account takeover - unauthorized access to user accounts',
            'PRIVILEGE_ESCALATION': 'Privilege escalation - attacker gains admin access',
            'DATA_EXFILTRATION': 'Data exfiltration - bulk data extraction',
            'BACKDOOR_INSTALLATION': 'Backdoor installation - persistent access established',
            'CREDENTIAL_EXPOSURE': 'Credential exposure - authentication secrets leaked',
            'SYSTEM_ACCESS': 'System access - attacker gains system-level control',
        }
        
        return impact_descriptions.get(category, f'High-severity impact from {category}')
    
    def _estimate_exploit_time(self, chain: AttackChain) -> str:
        """Estimate time to exploit the chain"""
        complexity_times = {
            AttackComplexity.TRIVIAL: "< 1 hour",
            AttackComplexity.LOW: "1-4 hours",
            AttackComplexity.MEDIUM: "4-8 hours",
            AttackComplexity.HIGH: "1-3 days",
        }
        return complexity_times.get(chain.complexity, "Unknown")
    
    def _calculate_statistics(self, chains: list[AttackChain]) -> dict:
        """Calculate statistics about found chains"""
        if not chains:
            return {
                'chain_count': 0,
                'avg_chain_length': 0,
                'avg_risk_score': 0,
                'max_risk_score': 0,
                'min_risk_score': 0,
                'by_exploitability': {},
                'by_complexity': {},
                'critical_chains': 0,
                'high_chains': 0,
            }
        
        return {
            'chain_count': len(chains),
            'avg_chain_length': sum(len(c.vulnerabilities) for c in chains) / len(chains),
            'avg_risk_score': sum(c.risk_score for c in chains) / len(chains),
            'max_risk_score': max(c.risk_score for c in chains),
            'min_risk_score': min(c.risk_score for c in chains),
            'by_exploitability': self._count_by_attribute(chains, 'exploitability'),
            'by_complexity': self._count_by_attribute(chains, 'complexity'),
            'critical_chains': sum(1 for c in chains if c.exploitability == ChainExploitability.CRITICAL),
            'high_chains': sum(1 for c in chains if c.exploitability == ChainExploitability.HIGH),
        }
    
    def _count_by_attribute(self, chains: list[AttackChain], attribute: str) -> dict:
        """Count chains by attribute value"""
        counts = defaultdict(int)
        for chain in chains:
            value = getattr(chain, attribute)
            if hasattr(value, 'value'):
                value = value.value
            counts[str(value)] += 1
        return dict(counts)


def main():
    """CLI entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Vulnerability Chaining Engine - Discover multi-step attack scenarios"
    )
    parser.add_argument('--input', '-i', required=True, help='Input findings JSON file')
    parser.add_argument('--output', '-o', help='Output chains JSON file')
    parser.add_argument('--max-length', type=int, default=4, help='Maximum chain length')
    parser.add_argument('--min-risk', type=float, default=5.0, help='Minimum risk threshold')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    # Configure logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    # Load findings
    with open(args.input) as f:
        data = json.load(f)
        findings = data.get('findings', data) if isinstance(data, dict) else data
    
    # Run analysis
    chainer = VulnerabilityChainer(
        max_chain_length=args.max_length,
        min_risk_threshold=args.min_risk
    )
    
    result = chainer.analyze(findings)
    
    # Save results
    if args.output:
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w') as f:
            json.dump(result, f, indent=2)
        
        print(f"\nâœ… Results saved to: {output_path}")
    else:
        print(json.dumps(result, indent=2))
    
    # Print summary
    print(f"\nðŸ“Š Vulnerability Chaining Summary:")
    print(f"   Total Vulnerabilities: {result['total_vulnerabilities']}")
    print(f"   Total Chains Found: {result['total_chains']}")
    print(f"   Critical Chains: {result['statistics']['critical_chains']}")
    print(f"   High-Risk Chains: {result['statistics']['high_chains']}")
    print(f"   Average Chain Length: {result['statistics']['avg_chain_length']:.1f}")
    print(f"   Average Risk Score: {result['statistics']['avg_risk_score']:.1f}/10.0")
    print(f"   Duration: {result['duration_seconds']:.1f}s")
    
    return 0


if __name__ == "__main__":
    exit(main())
