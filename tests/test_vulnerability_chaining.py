#!/usr/bin/env python3
"""
Comprehensive Test Suite for Vulnerability Chaining System
Tests all components: graph construction, chain detection, risk calculation
"""

import json
import sys
import unittest
from pathlib import Path

# Add scripts to path
sys.path.insert(0, str(Path(__file__).parent.parent / "scripts"))

from vulnerability_chaining_engine import (
    VulnerabilityNode,
    AttackChain,
    AttackGraph,
    VulnerabilityChainer,
    AttackComplexity,
    ChainExploitability,
)


class TestVulnerabilityNode(unittest.TestCase):
    """Test VulnerabilityNode functionality"""
    
    def test_node_creation(self):
        """Test creating a vulnerability node"""
        node = VulnerabilityNode(
            id="test-001",
            category="XSS",
            severity="high",
            title="Cross-Site Scripting",
            description="XSS vulnerability",
            file_path="/app/views.py",
            line_number=42,
        )
        
        self.assertEqual(node.id, "test-001")
        self.assertEqual(node.category, "XSS")
        self.assertEqual(node.severity, "high")
    
    def test_severity_to_score(self):
        """Test severity to numeric score conversion"""
        critical = VulnerabilityNode(
            id="1", category="RCE", severity="critical",
            title="Test", description="", file_path=""
        )
        high = VulnerabilityNode(
            id="2", category="SQLi", severity="high",
            title="Test", description="", file_path=""
        )
        medium = VulnerabilityNode(
            id="3", category="XSS", severity="medium",
            title="Test", description="", file_path=""
        )
        
        self.assertEqual(critical.severity_to_score(), 10.0)
        self.assertEqual(high.severity_to_score(), 7.5)
        self.assertEqual(medium.severity_to_score(), 5.0)


class TestAttackChain(unittest.TestCase):
    """Test AttackChain functionality"""
    
    def test_chain_creation(self):
        """Test creating an attack chain"""
        vulns = [
            VulnerabilityNode(
                id="idor-1", category="IDOR", severity="medium",
                title="IDOR", description="", file_path="/api/users.py"
            ),
            VulnerabilityNode(
                id="auth-1", category="AUTH", severity="high",
                title="Broken Auth", description="", file_path="/api/auth.py"
            ),
        ]
        
        chain = AttackChain(vulnerabilities=vulns)
        
        self.assertEqual(len(chain.vulnerabilities), 2)
        self.assertGreater(chain.risk_score, 0)
        self.assertTrue(chain.chain_id)
    
    def test_risk_amplification(self):
        """Test risk amplification calculation"""
        # Single vuln: no amplification
        single = AttackChain(vulnerabilities=[
            VulnerabilityNode(
                id="1", category="XSS", severity="medium",
                title="", description="", file_path=""
            )
        ])
        self.assertEqual(single.amplification_factor, 1.0)
        self.assertEqual(single.risk_score, 5.0)
        
        # Two vulns: 1.5x amplification
        double = AttackChain(vulnerabilities=[
            VulnerabilityNode(
                id="1", category="XSS", severity="medium",
                title="", description="", file_path=""
            ),
            VulnerabilityNode(
                id="2", category="CSRF", severity="medium",
                title="", description="", file_path=""
            ),
        ])
        self.assertEqual(double.amplification_factor, 1.5)
        self.assertAlmostEqual(double.base_risk, 10.0)
        self.assertLessEqual(double.risk_score, 10.0)
        
        # Three vulns: 2.25x amplification
        triple = AttackChain(vulnerabilities=[
            VulnerabilityNode(
                id=str(i), category="TEST", severity="medium",
                title="", description="", file_path=""
            )
            for i in range(3)
        ])
        self.assertEqual(triple.amplification_factor, 2.25)
    
    def test_complexity_determination(self):
        """Test attack complexity determination"""
        # Trivial: 1 step, easy exploit
        trivial = AttackChain(vulnerabilities=[
            VulnerabilityNode(
                id="1", category="SQLi", severity="critical",
                title="", description="", file_path="",
                exploitability="trivial"
            )
        ])
        self.assertEqual(trivial.complexity, AttackComplexity.TRIVIAL)
        
        # High: 4+ steps
        high = AttackChain(vulnerabilities=[
            VulnerabilityNode(
                id=str(i), category="TEST", severity="medium",
                title="", description="", file_path=""
            )
            for i in range(4)
        ])
        self.assertEqual(high.complexity, AttackComplexity.HIGH)


class TestAttackGraph(unittest.TestCase):
    """Test AttackGraph functionality"""
    
    def setUp(self):
        """Set up test graph"""
        self.graph = AttackGraph()
    
    def test_add_vulnerability(self):
        """Test adding vulnerabilities to graph"""
        vuln = VulnerabilityNode(
            id="test-1", category="XSS", severity="high",
            title="Test XSS", description="", file_path="/test.py"
        )
        
        self.graph.add_vulnerability(vuln)
        
        self.assertIn("test-1", self.graph.vulnerabilities)
        self.assertEqual(self.graph.vulnerabilities["test-1"], vuln)
    
    def test_can_chain_with_rules(self):
        """Test vulnerability chaining rules"""
        idor = VulnerabilityNode(
            id="1", category="IDOR", severity="medium",
            title="", description="", file_path="/api.py"
        )
        priv_esc = VulnerabilityNode(
            id="2", category="PRIVILEGE_ESCALATION", severity="high",
            title="", description="", file_path="/auth.py"
        )
        
        self.graph.add_vulnerability(idor)
        self.graph.add_vulnerability(priv_esc)
        
        can_chain, prob = self.graph.can_chain(idor, priv_esc)
        
        self.assertTrue(can_chain)
        self.assertGreater(prob, 0)
    
    def test_category_normalization(self):
        """Test category normalization"""
        self.assertEqual(self.graph._normalize_category("xss"), "XSS")
        self.assertEqual(self.graph._normalize_category("cross-site-scripting"), "XSS")
        self.assertEqual(self.graph._normalize_category("SQL_INJECTION"), "SQL_INJECTION")
        self.assertEqual(self.graph._normalize_category("sqli"), "SQL_INJECTION")
    
    def test_entry_points(self):
        """Test finding entry points"""
        # Add vulnerabilities
        entry = VulnerabilityNode(
            id="1", category="XSS", severity="high",
            title="", description="", file_path="",
            exploitability="trivial", reachability="yes"
        )
        internal = VulnerabilityNode(
            id="2", category="SQLi", severity="critical",
            title="", description="", file_path="",
            exploitability="difficult", reachability="no"
        )
        
        self.graph.add_vulnerability(entry)
        self.graph.add_vulnerability(internal)
        
        entry_points = self.graph.find_entry_points()
        
        self.assertIn(entry, entry_points)
        self.assertNotIn(internal, entry_points)
    
    def test_high_value_targets(self):
        """Test finding high-value targets"""
        # Add vulnerabilities
        data_breach = VulnerabilityNode(
            id="1", category="DATA_BREACH", severity="critical",
            title="", description="", file_path=""
        )
        info_leak = VulnerabilityNode(
            id="2", category="INFO_LEAK", severity="low",
            title="", description="", file_path=""
        )
        
        self.graph.add_vulnerability(data_breach)
        self.graph.add_vulnerability(info_leak)
        
        targets = self.graph.find_high_value_targets()
        
        self.assertIn(data_breach, targets)


class TestVulnerabilityChainer(unittest.TestCase):
    """Test VulnerabilityChainer functionality"""
    
    def test_simple_chain_detection(self):
        """Test detecting a simple 2-step chain"""
        findings = [
            {
                'id': 'idor-1',
                'category': 'IDOR',
                'severity': 'medium',
                'title': 'Insecure Direct Object Reference',
                'description': 'Missing access control',
                'path': '/api/users.py',
                'line': 42,
                'exploitability': 'trivial',
                'reachability': 'yes',
            },
            {
                'id': 'priv-1',
                'category': 'PRIVILEGE_ESCALATION',
                'severity': 'high',
                'title': 'Privilege Escalation',
                'description': 'Can escalate to admin',
                'path': '/api/auth.py',
                'line': 100,
                'exploitability': 'moderate',
                'reachability': 'yes',
            },
        ]
        
        chainer = VulnerabilityChainer(max_chain_length=3, min_risk_threshold=0.0)
        result = chainer.analyze(findings)
        
        self.assertIn('chains', result)
        self.assertIn('statistics', result)
        self.assertGreater(result['total_vulnerabilities'], 0)
    
    def test_complex_chain_scenario(self):
        """Test detecting a complex multi-step chain"""
        findings = [
            # Entry point: XSS
            {
                'id': 'xss-1',
                'category': 'XSS',
                'severity': 'medium',
                'title': 'Stored XSS',
                'path': '/app/views.py',
                'exploitability': 'trivial',
                'reachability': 'yes',
            },
            # Step 2: Session hijacking
            {
                'id': 'session-1',
                'category': 'SESSION_HIJACKING',
                'severity': 'high',
                'title': 'Session Token Exposure',
                'path': '/app/auth.py',
                'exploitability': 'moderate',
                'reachability': 'yes',
            },
            # Final target: Account takeover
            {
                'id': 'account-1',
                'category': 'ACCOUNT_TAKEOVER',
                'severity': 'critical',
                'title': 'Account Takeover',
                'path': '/app/users.py',
                'exploitability': 'moderate',
                'reachability': 'yes',
            },
        ]
        
        chainer = VulnerabilityChainer(max_chain_length=4, min_risk_threshold=0.0)
        result = chainer.analyze(findings)
        
        # Should find at least one chain
        self.assertGreaterEqual(result['total_chains'], 0)
        
        if result['total_chains'] > 0:
            chain = result['chains'][0]
            self.assertIn('risk_score', chain)
            self.assertIn('vulnerabilities', chain)
            self.assertGreater(chain['risk_score'], 0)
    
    def test_no_chains_found(self):
        """Test when no chains can be formed"""
        findings = [
            # Unrelated vulnerabilities that don't chain
            {
                'id': 'low-1',
                'category': 'HARDCODED_SECRET',
                'severity': 'low',
                'title': 'Hardcoded API Key',
                'path': '/config.py',
                'exploitability': 'difficult',
                'reachability': 'no',
            },
        ]
        
        chainer = VulnerabilityChainer(max_chain_length=3, min_risk_threshold=8.0)
        result = chainer.analyze(findings)
        
        # Might not find any chains above threshold
        self.assertGreaterEqual(result['total_chains'], 0)
    
    def test_risk_threshold_filtering(self):
        """Test that risk threshold filters chains"""
        findings = [
            {'id': f'vuln-{i}', 'category': 'TEST', 'severity': 'low',
             'title': '', 'path': '', 'exploitability': 'difficult', 'reachability': 'no'}
            for i in range(5)
        ]
        
        chainer_low = VulnerabilityChainer(min_risk_threshold=0.0)
        chainer_high = VulnerabilityChainer(min_risk_threshold=9.0)
        
        result_low = chainer_low.analyze(findings)
        result_high = chainer_high.analyze(findings)
        
        # High threshold should filter out more chains
        self.assertGreaterEqual(result_low['total_chains'], result_high['total_chains'])


class TestIntegration(unittest.TestCase):
    """Integration tests for complete workflow"""
    
    def test_end_to_end_analysis(self):
        """Test complete end-to-end analysis"""
        # Realistic vulnerability set
        findings = [
            {
                'id': 'CVE-2024-001',
                'category': 'SSRF',
                'severity': 'high',
                'title': 'Server-Side Request Forgery',
                'description': 'SSRF in image proxy',
                'path': '/api/proxy.py',
                'line': 45,
                'cwe': 'CWE-918',
                'exploitability': 'moderate',
                'reachability': 'yes',
            },
            {
                'id': 'CVE-2024-002',
                'category': 'PATH_TRAVERSAL',
                'severity': 'medium',
                'title': 'Path Traversal',
                'description': 'Directory traversal vulnerability',
                'path': '/api/files.py',
                'line': 120,
                'cwe': 'CWE-22',
                'exploitability': 'trivial',
                'reachability': 'yes',
            },
            {
                'id': 'CVE-2024-003',
                'category': 'COMMAND_INJECTION',
                'severity': 'critical',
                'title': 'Command Injection',
                'description': 'OS command injection',
                'path': '/api/process.py',
                'line': 78,
                'cwe': 'CWE-78',
                'exploitability': 'moderate',
                'reachability': 'partial',
            },
        ]
        
        chainer = VulnerabilityChainer()
        result = chainer.analyze(findings)
        
        # Validate result structure
        self.assertIn('timestamp', result)
        self.assertIn('total_vulnerabilities', result)
        self.assertIn('total_chains', result)
        self.assertIn('chains', result)
        self.assertIn('statistics', result)
        self.assertIn('duration_seconds', result)
        
        # Validate statistics
        stats = result['statistics']
        self.assertIn('chain_count', stats)
        self.assertIn('avg_chain_length', stats)
        self.assertIn('by_exploitability', stats)
        
        # Validate chains structure if any found
        if result['total_chains'] > 0:
            chain = result['chains'][0]
            self.assertIn('chain_id', chain)
            self.assertIn('vulnerabilities', chain)
            self.assertIn('risk_score', chain)
            self.assertIn('complexity', chain)
            self.assertIn('exploitability', chain)


def run_tests():
    """Run all tests"""
    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Add all test classes
    suite.addTests(loader.loadTestsFromTestCase(TestVulnerabilityNode))
    suite.addTests(loader.loadTestsFromTestCase(TestAttackChain))
    suite.addTests(loader.loadTestsFromTestCase(TestAttackGraph))
    suite.addTests(loader.loadTestsFromTestCase(TestVulnerabilityChainer))
    suite.addTests(loader.loadTestsFromTestCase(TestIntegration))
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1)
